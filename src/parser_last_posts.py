import asyncio
import aiohttp
import re
from datetime import datetime, timedelta
from collections import deque
from telethon import TelegramClient, events
from telethon.tl.functions.messages import GetHistoryRequest
from bs4 import BeautifulSoup
import config


class ChannelMonitor:
    def __init__(self):
        self.last_checked_id = 0
        self.processed_ids = set()
        self.client = None
        self.output_channel = None
        self.private_channel = None
        self.message_queue = deque()
        self.current_message_processing = None
        self.article_timeouts = {}
        self.pending_responses = {}
        self.api_request_lock = asyncio.Lock()
        self.processing_lock = asyncio.Lock()
        self.processing_active = False
        self.autopiter_session = aiohttp.ClientSession()

    async def initialize(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞ Telegram –∏ –∫–∞–Ω–∞–ª–æ–≤"""
        self.client = TelegramClient('session_name', config.API_ID, config.API_HASH)
        await self.client.start(config.PHONE_NUMBER)

        try:
            self.output_channel = await self.client.get_entity(config.OUTPUT_CHANNEL_ID)
            self.private_channel = await self.client.get_entity(config.PRIVATE_CHANNEL_ID)

            print("‚úÖ –ë–æ—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")

            output_name = getattr(self.output_channel, 'title',
                                  getattr(self.output_channel, 'username',
                                          getattr(self.output_channel, 'first_name', 'N/A')))
            private_name = getattr(self.private_channel, 'title',
                                   getattr(self.private_channel, 'username',
                                           getattr(self.private_channel, 'first_name', 'N/A')))

            print(f"üì¢ –í—ã—Ö–æ–¥–Ω–æ–π –∫–∞–Ω–∞–ª: {output_name}")
            print(f"üîí –ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–∞–Ω–∞–ª: {private_name}")

        except Exception as e:
            print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–∞–Ω–∞–ª–æ–≤: {e}")
            raise

    async def fetch_autopiter_price(self, article):
        """–ü–∞—Ä—Å–∏–Ω–≥ —Ü–µ–Ω—ã —Å Autopiter —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π –∞—Ä—Ç–∏–∫—É–ª–∞"""
        url = f"https://autopiter.ru/goods/{article}"
        headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
        }

        try:
            async with self.autopiter_session.get(url, headers=headers, timeout=15) as response:
                if response.status != 200:
                    print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ HTTP {response.status} –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ Autopiter")
                    return None

                html = await response.text()
                soup = BeautifulSoup(html, 'html.parser')

                # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –∞—Ä—Ç–∏–∫—É–ª–∞
                base_article = article.strip()
                article_variants = {
                    'original': base_article,
                    'lower': base_article.lower(),
                    'upper': base_article.upper(),
                    'no_special_chars': re.sub(r'[-_/]', '', base_article),
                    'no_special_lower': re.sub(r'[-_/]', '', base_article).lower(),
                    'no_special_upper': re.sub(r'[-_/]', '', base_article).upper(),
                    'letters_only': re.sub(r'[^A-Za-z]', '', base_article),
                    'digits_only': re.sub(r'[^0-9]', '', base_article),
                    'combined': re.sub(r'[-_/]', '', base_article).replace(' ', '')
                }

                # –ò—â–µ–º –≤—Å–µ span —ç–ª–µ–º–µ–Ω—Ç—ã —Å CSS-—Å–µ–ª–µ–∫—Ç–æ—Ä–æ–º, —Å–æ–¥–µ—Ä–∂–∞—â–∏–º MobileSearchingResultItem__article
                article_spans = soup.select('span[class^="MobileSearchingResultItem"]')
                print(article_spans)
                for article_span in article_spans:
                    product_article = article_span.get_text(strip=True)

                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –∞—Ä—Ç–∏–∫—É–ª–∞
                    for var_name, var_value in article_variants.items():
                        normalized_product = re.sub(r'\s+', '', product_article).lower()
                        normalized_variant = re.sub(r'\s+', '', var_value).lower()

                        if normalized_variant in normalized_product:
                            # –ü–æ–¥–Ω–∏–º–∞–µ–º—Å—è –Ω–∞ 5 —É—Ä–æ–≤–Ω–µ–π –≤–≤–µ—Ä—Ö
                            parent = article_span
                            for _ in range(5):
                                parent = parent.parent
                                if parent is None:
                                    break

                            if parent is not None:
                                # –ò—â–µ–º span —Å –Ω—É–∂–Ω—ã–º –∫–ª–∞—Å—Å–æ–º —Å—Ç–∞—Ç—É—Å–∞ (–≥–¥–µ —É–∂–µ –µ—Å—Ç—å —Ü–µ–Ω–∞)
                                status_span = parent.select_one('span[class^="Status__root"]')
                                print(status_span)
                                if status_span:
                                    # –ò–∑–≤–ª–µ–∫–∞–µ–º –≤–µ—Å—å —Ç–µ–∫—Å—Ç –∏–∑ —Å–ø–∞–Ω–∞ —Å—Ç–∞—Ç—É—Å–∞
                                    status_text = status_span.get_text(strip=True)

                                    # –ò—â–µ–º —á–∏—Å–ª–æ –≤ —Ç–µ–∫—Å—Ç–µ (–º–æ–∂–µ—Ç –±—ã—Ç—å "–û—Ç 3256 ‚ÇΩ" –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ "3256 ‚ÇΩ")
                                    price_match = re.search(r'\d+[\s,.]?\d*', status_text)
                                    if price_match:
                                        try:
                                            # –û—á–∏—â–∞–µ–º —Ü–µ–Ω—É –æ—Ç –ø—Ä–æ–±–µ–ª–æ–≤ –∏ –∑–∞–º–µ–Ω—è–µ–º –∑–∞–ø—è—Ç—ã–µ –Ω–∞ —Ç–æ—á–∫–∏
                                            price_text = price_match.group(0).replace(' ', '').replace(',', '.')
                                            price = float(price_text)
                                            print(
                                                f"‚úÖ –°–æ–≤–ø–∞–¥–µ–Ω–∏–µ –∞—Ä—Ç–∏–∫—É–ª–∞ '{base_article}' (–≤–∞—Ä–∏–∞–Ω—Ç {var_name}) | –¶–µ–Ω–∞: {price}")
                                            return price
                                        except ValueError as e:
                                            print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è —Ü–µ–Ω—ã '{price_match.group(0)}': {str(e)}")
                                            continue

                print(f"‚ö†Ô∏è –ê—Ä—Ç–∏–∫—É–ª '{base_article}' –Ω–µ –Ω–∞–π–¥–µ–Ω —Å—Ä–µ–¥–∏ {len(article_variants)} –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤")
                return None

        except Exception as e:
            print(f"‚ö†Ô∏è –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥–µ Autopiter: {str(e)}")
            return None

    async def extract_articles_with_perplexity(self, message_text):
        """–ó–∞–ø—Ä–æ—Å –∫ Perplexity API –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –∞—Ä—Ç–∏–∫—É–ª–æ–≤"""
        url = "https://api.perplexity.ai/chat/completions"
        headers = {
            "Authorization": f"Bearer {config.PERPLEXITY_API_KEY}",
            "Content-Type": "application/json"
        }

        system_prompt = """–¢—ã –ø–æ–º–æ–≥–∞–µ—à—å –∏–∑–≤–ª–µ–∫–∞—Ç—å –∞—Ä—Ç–∏–∫—É–ª—ã —Ç–æ–≤–∞—Ä–æ–≤. –ü—Ä–∞–≤–∏–ª–∞:
1. –ù–∞–π–¥–∏ –≤—Å–µ –∞—Ä—Ç–∏–∫—É–ª—ã (–∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ –±—É–∫–≤, —Ü–∏—Ñ—Ä –∏ –¥–µ—Ñ–∏—Å–æ–≤)
2. –û–ø—Ä–µ–¥–µ–ª–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 1)
3. –í—ã–≤–µ–¥–∏ —Å—Ç—Ä–æ–≥–æ –≤ —Ñ–æ—Ä–º–∞—Ç–µ: –∞—Ä—Ç–∏–∫—É–ª: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
4. –¢–æ–ª—å–∫–æ —Ñ–∞–∫—Ç—ã, –±–µ–∑ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤!"""

        payload = {
            "model": "sonar-pro",
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": f"–ò–∑–≤–ª–µ–∫–∏ –∞—Ä—Ç–∏–∫—É–ª—ã:\n{message_text}"}
            ],
            "temperature": 0.1,
            "max_tokens": 1000
        }

        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(
                        url,
                        json=payload,
                        headers=headers,
                        timeout=aiohttp.ClientTimeout(total=30)
                ) as response:

                    if response.status == 200:
                        data = await response.json()
                        content = data['choices'][0]['message']['content']

                        result = []
                        for line in content.split('\n'):
                            line = line.strip()
                            if re.match(r'^[\w\d-]+:\s*\d+$', line):
                                result.append(line)

                        return {'done': '\n'.join(result)} if result else None

                    print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ API (—Å—Ç–∞—Ç—É—Å {response.status}): {await response.text()}")
                    return None

        except Exception as e:
            print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∫ Perplexity: {str(e)}")
            return None

    async def process_message_queue(self):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—á–µ—Ä–µ–¥–∏ —Å–æ–æ–±—â–µ–Ω–∏–π"""
        while True:
            try:
                if self.message_queue and not self.processing_active:
                    async with self.processing_lock:
                        if self.message_queue and not self.processing_active:
                            self.processing_active = True
                            message_data = self.message_queue.popleft()

                            print(f"\nüöÄ –ù–∞—á–∞—Ç–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è ID: {message_data['message'].id}")

                            processing_data = {
                                'message': message_data['message'],
                                'user': message_data['user'],
                                'articles_data': [],
                                'responses': [],
                                'timestamp': datetime.now(),
                                'pending_articles': set(),
                                'total_articles': 0
                            }

                            api_response = await self.extract_articles_with_perplexity(
                                message_data['message'].message
                            )

                            if api_response:
                                await self.process_api_response(processing_data, api_response)

                                processing_data['total_articles'] = len(processing_data['articles_data'])

                                for article in processing_data['articles_data']:
                                    await self.client.send_message(
                                        self.output_channel,
                                        article['article']
                                    )
                                    self.article_timeouts[article['article']] = datetime.now()
                                    processing_data['pending_articles'].add(article['article'])
                                    self.pending_responses[article['article']] = processing_data

                                    autopiter_price = await self.fetch_autopiter_price(article['article'])
                                    if autopiter_price is not None:
                                        article['autopiter_price'] = autopiter_price
                                        print(f"üõí –¶–µ–Ω–∞ —Å Autopiter –¥–ª—è {article['article']}: {autopiter_price}")

                                self.current_message_processing = processing_data
                            else:
                                print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ")
                                self.processing_active = False
                await asyncio.sleep(1)
            except Exception as e:
                print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –≤ process_message_queue: {e}")
                self.processing_active = False
                await asyncio.sleep(5)

    async def process_api_response(self, processing_data, api_response):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–≤–µ—Ç–∞ –æ—Ç API"""
        if not api_response or 'done' not in api_response:
            return

        for line in api_response['done'].split('\n'):
            try:
                article, quantity = map(str.strip, line.split(':'))
                processing_data['articles_data'].append({
                    'article': article,
                    'quantity': float(quantity),
                    'processed': False,
                    'found': None,
                    'response_data': None,
                    'autopiter_price': None
                })
                print(f"üîç –ù–∞–π–¥–µ–Ω –∞—Ä—Ç–∏–∫—É–ª: {article} ({quantity} —à—Ç.)")
            except Exception as e:
                print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å—Ç—Ä–æ–∫–∏: {line}")

    async def handle_output_channel_response(self, response_message):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–≤–µ—Ç–∞ –æ—Ç –≤—Ç–æ—Ä–æ–≥–æ –±–æ—Ç–∞ —Å —Ü–µ–Ω–∞–º–∏"""
        try:
            if not response_message.out and response_message.sender_id == self.output_channel.id:
                bot_data = self.parse_second_bot_response(response_message.message)
                if not bot_data:
                    return

                found_articles = set()
                for article in list(self.pending_responses.keys()):
                    if article in response_message.message:
                        processing_data = self.pending_responses.get(article)
                        if not processing_data:
                            continue

                        for article_data in processing_data['articles_data']:
                            if article_data['article'] == article and not article_data['processed']:
                                article_data.update({
                                    'processed': True,
                                    'found': bot_data['found'],
                                    'response_data': bot_data
                                })

                                if bot_data['found']:
                                    processing_data['responses'].append({
                                        'article_data': article_data,
                                        'bot_data': bot_data
                                    })
                                    print(f"üí∞ –ü–æ–ª—É—á–µ–Ω–∞ —Ü–µ–Ω–∞ –¥–ª—è {article}")

                                found_articles.add(article)
                                processing_data['pending_articles'].discard(article)

                                if (len(processing_data['responses']) +
                                    sum(1 for a in processing_data['articles_data']
                                        if a['processed'] and not a['found'])) == processing_data['total_articles']:
                                    await self.finalize_processing(processing_data)
                                    return

                for article in found_articles:
                    if article in self.pending_responses:
                        del self.pending_responses[article]
                    if article in self.article_timeouts:
                        del self.article_timeouts[article]
        except Exception as e:
            print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –≤ handle_output_channel_response: {e}")

    def parse_second_bot_response(self, response_text):
        """–ü–∞—Ä—Å–∏–Ω–≥ –æ—Ç–≤–µ—Ç–∞ –æ—Ç –≤—Ç–æ—Ä–æ–≥–æ –±–æ—Ç–∞"""
        result = {
            'name': None,
            'price': None,
            'stock_quantity': None,
            'found': False
        }

        try:
            if "–ê—Ä—Ç–∏–∫—É–ª –Ω–µ –Ω–∞–π–¥–µ–Ω" not in response_text:
                if name_match := re.search(r'–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ:\s*(.*)', response_text):
                    result['name'] = name_match.group(1).strip()
                if price_match := re.search(r'–¶–µ–Ω–∞ –∑–∞ —à—Ç—É–∫—É:\s*([\d.,]+)', response_text):
                    result['price'] = float(price_match.group(1).replace(',', '.'))
                    result['found'] = True
                if stock_match := re.search(r'–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–∞ —Å–∫–ª–∞–¥–µ:\s*(\d+)', response_text):
                    result['stock_quantity'] = int(stock_match.group(1))
        except Exception as e:
            print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞: {e}")

        return result

    async def check_timeouts(self):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∞–π–º–∞—É—Ç–æ–≤ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∞—Ä—Ç–∏–∫—É–ª–æ–≤"""
        while True:
            try:
                now = datetime.now()
                timeout = timedelta(seconds=60)

                for article, timestamp in list(self.article_timeouts.items()):
                    if (now - timestamp) > timeout:
                        processing_data = self.pending_responses.get(article)
                        if processing_data:
                            for article_data in processing_data['articles_data']:
                                if article_data['article'] == article and not article_data['processed']:
                                    article_data.update({
                                        'processed': True,
                                        'found': False,
                                        'response_data': None
                                    })
                                    print(f"‚è∞ –¢–∞–π–º–∞—É—Ç –¥–ª—è –∞—Ä—Ç–∏–∫—É–ª–∞ {article}")

                            processing_data['pending_articles'].discard(article)
                            if article in self.pending_responses:
                                del self.pending_responses[article]
                            if article in self.article_timeouts:
                                del self.article_timeouts[article]

                            if (len(processing_data['responses']) +
                                sum(1 for a in processing_data['articles_data']
                                    if a['processed'] and not a['found'])) == processing_data['total_articles']:
                                await self.finalize_processing(processing_data)
                await asyncio.sleep(5)
            except Exception as e:
                print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –≤ check_timeouts: {e}")
                await asyncio.sleep(10)

    async def finalize_processing(self, processing_data):
        """–§–∏–Ω–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞"""
        try:
            if not processing_data:
                return

            priced_items = [
                r for r in processing_data['responses']
                if r['article_data']['found']
            ]

            if priced_items or any(a.get('autopiter_price') is not None for a in processing_data['articles_data']):
                await self.send_to_private_channel(processing_data)
            else:
                print("‚ÑπÔ∏è –ù–µ—Ç —Ä–∞—Å—Ü–µ–Ω–µ–Ω–Ω—ã—Ö –∞—Ä—Ç–∏–∫—É–ª–æ–≤")

            if processing_data == self.current_message_processing:
                self.cleanup_processing()
        except Exception as e:
            print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –≤ finalize_processing: {e}")
            self.cleanup_processing()

    async def send_to_private_channel(self, processing_data):
        """–§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –≤ –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–∞–Ω–∞–ª"""
        try:
            original_message = processing_data['message']
            channel_entity = await self.client.get_entity(original_message.peer_id)
            post_link = f"https://t.me/c/{channel_entity.id}/{original_message.id}"

            response_text = f"üìé [–ò—Å—Ö–æ–¥–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ]({post_link})\n"
            response_text += "üìä –†–µ–∑—É–ª—å—Ç–∞—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∞—Ä—Ç–∏–∫—É–ª–æ–≤:\n"

            total_sum = 0

            for article_data in processing_data['articles_data']:
                if article_data['found'] or article_data.get('autopiter_price') is not None:
                    response_text += f"\nüîπ –ê—Ä—Ç–∏–∫—É–ª: {article_data['article']}\n"
                    response_text += f"üì¶ –ó–∞–ø—Ä–æ—à–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: {int(article_data['quantity'])}\n"

                    if article_data['found']:
                        bot_data = article_data['response_data']
                        item_total = bot_data['price'] * article_data['quantity']
                        total_sum += item_total

                        stock_info = f" ({bot_data['stock_quantity']} —à—Ç –Ω–∞ —Å–∫–ª–∞–¥–µ)" if bot_data[
                            'stock_quantity'] else ""

                        response_text += (
                            f"üè∑Ô∏è –ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ: {bot_data['name'] or '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'}{stock_info}\n"
                            f"üí∞ –¶–µ–Ω–∞ –∑–∞ —à—Ç—É–∫—É: {bot_data['price']:.2f} ‚ÇΩ/—à—Ç\n"
                        )

                    if article_data.get('autopiter_price') is not None:
                        response_text += f"üõí –¶–µ–Ω–∞ –Ω–∞ Autopiter: {article_data['autopiter_price']:.2f} ‚ÇΩ/—à—Ç\n"

            if total_sum > 0:
                response_text += f"\nüíµ –û–±—â–∞—è —Å—É–º–º–∞: {total_sum:.2f} ‚ÇΩ\n"

            await self.client.send_message(
                entity=self.private_channel,
                message=response_text,
                link_preview=False
            )

            print(f"‚úâÔ∏è –†–µ–∑—É–ª—å—Ç–∞—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–∞–Ω–∞–ª")
        except Exception as e:
            print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –≤ –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–∞–Ω–∞–ª: {e}")

    def cleanup_processing(self):
        """–û—á–∏—Å—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ—Å–ª–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏"""
        self.processing_active = False
        self.current_message_processing = None
        self.article_timeouts.clear()
        self.pending_responses.clear()

    async def monitor_output_channel(self):
        """–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –æ—Ç–≤–µ—Ç–æ–≤ –æ—Ç –≤—Ç–æ—Ä–æ–≥–æ –±–æ—Ç–∞"""
        print("üëÇ –ù–∞—á–∞–ª–æ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –≤—ã—Ö–æ–¥–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞...")

        @self.client.on(events.NewMessage(chats=self.output_channel))
        async def handler(event):
            try:
                await self.handle_output_channel_response(event.message)
            except Exception as e:
                print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")

        while True:
            await asyncio.sleep(10)

    async def process_messages(self, user, messages):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –∏–∑ –∫–∞–Ω–∞–ª–∞"""
        new_messages = [msg for msg in messages if msg.id > self.last_checked_id]

        if not new_messages:
            return

        new_messages.sort(key=lambda x: x.id)
        messages_to_process = new_messages[-10:]

        for message in messages_to_process:
            if not message.message:
                continue

            print(f"\nüì• –ù–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –æ—á–µ—Ä–µ–¥–∏ (ID: {message.id})")
            self.message_queue.append({
                'message': message,
                'user': user
            })

        self.last_checked_id = max(msg.id for msg in messages_to_process)

    async def close(self):
        """–ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ —Å–µ—Å—Å–∏–π"""
        await self.autopiter_session.close()
        await self.client.disconnect()


async def main():
    monitor = ChannelMonitor()
    await monitor.initialize()

    try:
        input_channel = await monitor.client.get_entity(config.CHANNEL_ID)
        user = await monitor.client.get_entity(config.USER_ID)

        print(f"\nüîç –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∫–∞–Ω–∞–ª–∞: {input_channel.title}")
        print(f"üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {user.first_name if user.first_name else user.username}\n")

        tasks = [
            asyncio.create_task(monitor.monitor_output_channel()),
            asyncio.create_task(monitor.check_timeouts()),
            asyncio.create_task(monitor.process_message_queue())
        ]

        while True:
            try:
                history = await monitor.client(GetHistoryRequest(
                    peer=input_channel,
                    limit=100,
                    offset_date=None,
                    offset_id=0,
                    max_id=0,
                    min_id=monitor.last_checked_id,
                    add_offset=0,
                    hash=0
                ))

                if history.messages:
                    await monitor.process_messages(user, history.messages)

                await asyncio.sleep(60)
            except Exception as e:
                print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞: {e}")
                await asyncio.sleep(10)

    except Exception as e:
        print(f"üö® –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
    finally:
        await monitor.close()
        print("üî¥ –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")


if __name__ == '__main__':
    print("üü¢ –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∞—Ä—Ç–∏–∫—É–ª–æ–≤")
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nüî¥ –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")